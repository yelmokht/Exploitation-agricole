from copy import deepcopy
from random import randint, random, choice

import numpy as np
from tqdm import tqdm

from Plot import Plot
from Solution import Solution
from constants import POPULATION_SIZE, ITERATIONS_LOCAL_RESEARCH, ITERATIONS_NUMBER, BUDGET, W1, W2, W3, OUTPUT, PRODUCTIVITY_MAX, PROXIMITY_MAX, COMPACTNESS_MAX


class Population:
    """
    Classe Population représentant une population de solutions.

    Attributs :
        - data : Les données associées à la population
        - occupancy_matrix : La matrice d'occupation
        - solutions : La liste des solutions
        - non_dominated_solutions : La liste des solutions non dominées
        - best_solution : La meilleure solution trouvée
    """

    def __init__(self, data):
        self.data = data
        self.occupancy_matrix = data.get_occupancy_matrix()
        self.solutions = []
        self.non_dominated_solutions = []
        self.selected_solution = None

    def get_solutions(self):
        return self.solutions

    def get_non_dominated_solutions(self):
        self.set_non_dominated_solutions()
        return self.non_dominated_solutions

    def get_selected_solution(self):
        return self.selected_solution

    def set_solutions(self, new_solutions):
        self.solutions.clear()
        self.solutions = new_solutions

    def set_non_dominated_solutions(self):
        """
        Définit les solutions non dominées.

        Cette méthode calcule les solutions non dominées dans la population en parcourant chaque solution
        et en vérifiant si elle est dominée par une autre solution. Les solutions non dominées sont
        stockées dans l'attribut non_dominated_solutions.
        """
        non_dominated_solutions = []
        for solution in self.solutions:
            is_non_dominated = True
            for other_solution in self.solutions:
                if self.is_pareto_dominant(other_solution, solution):
                    is_non_dominated = False
                    break
            if is_non_dominated:
                non_dominated_solutions.append(solution)
        self.non_dominated_solutions = non_dominated_solutions

    def is_plot_in_grid(self, x, y):
        """
        Vérifie si une parcelle se trouve dans la grille.

        :param x: La coordonnée x de la parcelle.
        :param y: La coordonnée y de la parcelle.
        :return: True si la parcelle se trouve dans la grille, False sinon.
        """
        return 0 <= x < len(self.occupancy_matrix) and 0 <= y < len(self.occupancy_matrix[0])

    def is_plot_unoccupied(self, x, y):
        """
        Vérifie si une parcelle est inoccupée.

        :param x: La coordonnée x de la parcelle.
        :param y: La coordonnée y de la parcelle.
        :return: True si la parcelle est inoccupée, False sinon.
        """
        return self.occupancy_matrix[(x, y)] != 0

    @staticmethod
    def step(iteration, index):
        """
        Calcule le pas pour une itération donnée.

        Le pas est calculé en fonction de l'itération et de l'index spécifié. Si la valeur absolue de l'index est
        égale à l'itération, le pas est de 1. Sinon, le pas est de 2 fois la valeur de l'itération.
        Le pas permet de passer les parcelles déjà vérifiées.

        :param iteration: L'itération courante.
        :param index: L'index spécifié.
        :return: Le pas calculé.
        """
        if abs(index) == iteration:
            pas = 1
        else:
            pas = 2 * iteration
        return pas

    def generate_random_plot(self):
        """
        Génère une parcelle en fonction du compteur.

        Cette méthode permet de générer des parcelles espacées de façon égales pour recouvrir la grille au maximum.
        Si la parcelle générée se trou
        ve dans la grille et est inoccupée, elle est retournée en tant qu'objet Plot.
        Sinon, on explore les parcelles voisines jusqu'à trouver une parcelle valide.

        :param counter: Le compteur de la population.
        :return: Un objet Plot
        """
        while True:
            (x, y) = (randint(0, len(self.occupancy_matrix) - 1), randint(0, len(self.occupancy_matrix[0]) - 1))
            if self.is_plot_unoccupied(x, y):
                return Plot(x, y, self.data)

    def generate_random_solution(self, center_plot: Plot):
        """
        Génère une solution aléatoire à partir d'une parcelle centrale.

        Cette méthode génère une solution aléatoire en ajoutant des parcelles autour d'une parcelle centrale spécifiée.
        Les parcelles sont ajoutées de manière itérative en explorant les parcelles voisines tout autour
        jusqu'à ce que la limite du budget soit atteinte ou qu'aucune parcelle ne puisse être ajoutée.

        :param center_plot: La parcelle centrale spécifiée.
        :return: Une solution générée aléatoirement.
        """
        solution = Solution(center_plot)
        size = randint(1, 25)
        iteration = 1
        while solution.get_cost() <= BUDGET and len(solution.get_plots_list()) < size:
            for k in range(-iteration, iteration + 1):
                for l in range(-iteration, iteration + 1, self.step(iteration, k)):
                    (x, y) = (center_plot.get_x() + k, center_plot.get_y() + l)
                    if self.is_plot_in_grid(x, y) and self.is_plot_unoccupied(x, y):
                        new_plot = Plot(x, y, self.data)
                        if solution.is_plot_addable(new_plot):
                            if random() < 0.5:
                                solution.add_plot(new_plot)
                        else:
                            return solution
            iteration += 1
        return solution

    def generate_initial_population(self):
        """
        Génère la population initiale.

        Cette méthode génère la population initiale en itérant sur la taille de la population et en générant une
        solution aléatoire à partir d'une parcelle générée. Les solutions initiales générées sont enfin ajoutées
        à la liste des solutions de la population.
        """
        for counter in range(POPULATION_SIZE):
            plot = self.generate_random_plot()
            solution = self.generate_random_solution(plot)
            self.solutions.append(solution)

    @staticmethod
    def is_pareto_dominant(new_solution, old_solution):
        """
        Vérifie si une nouvelle solution domine une ancienne solution.

        Cette méthode compare les valeurs de productivité, de proximité aux zones habitées et de compacité entre la
        nouvelle solution et l'ancienne solution. Si la nouvelle solution est supérieure ou égale en productivité,
        inférieure ou égale en proximité aux zones habitées, et supérieure ou égale en compacité, alors elle domine
        l'ancienne solution.

        :param new_solution: La nouvelle solution à comparer.
        :param old_solution: L'ancienne solution à comparer.
        :return: True si la nouvelle solution domine l'ancienne solution, False sinon.
        """
        if new_solution.get_productivity() >= old_solution.get_productivity() and new_solution.get_inhabited_area_proximity() < old_solution.get_inhabited_area_proximity() and new_solution.get_compactness() >= old_solution.get_compactness():
            return new_solution.get_productivity() > old_solution.get_productivity() or new_solution.get_inhabited_area_proximity() < old_solution.get_inhabited_area_proximity() or new_solution.get_compactness() > old_solution.get_compactness()
        return False

    def explore_neighbourhood_solution_fsf(self, solution: Solution):
        """
        Méthode de recherche de voisinage : First Solution Found (FSF).

        Cette méthode explore le voisinage d'une solution donnée en choisissant aléatoirement une des
        parcelles de la solution, puis en déplaçant cette parcelle dans une direction aléatoire. Si le
        déplacement conduit à une parcelle valide et ajoutable, la nouvelle solution est retournée.
        Sinon, si le déplacement conduit à une parcelle valide, mais échangeable, un échange est effectué
        entre la parcelle sélectionnée et la nouvelle parcelle, et la nouvelle solution est retournée.

        :param solution: La solution à explorer
        :return: La nouvelle solution trouvée dans le voisinage
        """
        new_solution = deepcopy(solution)
        for _ in range(100):
            selected_plot = choice(new_solution.get_plots_list())
            (x, y) = (selected_plot.get_x() + randint(-1, 1), selected_plot.get_y() + randint(-1, 1))
            if self.is_plot_in_grid(x, y) and self.is_plot_unoccupied(x, y) and (x, y) not in solution.get_coordinates_list():
                new_plot = Plot(x, y, self.data)
                if new_solution.is_plot_addable(new_plot):
                    new_solution.add_plot(new_plot)
                    return new_solution
                if new_solution.is_plot_swappable(selected_plot, new_plot):
                    new_solution.swap_plot(selected_plot, new_plot)
                    return new_solution
        return solution

    def find_better_solution(self, solution):
        """
        Cette méthode effectue une recherche locale en explorant le voisinage de la solution donnée.
        Elle utilise la méthode FSF (First Solution Found) pour explorer le voisinage et recherche
        une solution qui domine la solution donnée. La recherche locale est répétée un certain nombre d'itérations
        définies par la constante ITERATIONS_LOCAL_RESEARCH.

        :param solution: La solution à améliorer
        :return: La meilleure solution trouvée localement
        """
        for _ in range(ITERATIONS_LOCAL_RESEARCH):
            better_solution = self.explore_neighbourhood_solution_fsf(solution)  # First solution found
            if self.is_pareto_dominant(better_solution, solution):
                return better_solution
        return solution

    def find_best_solution(self):
        """
        Cette méthode trouve la meilleure solution en sélectionnant le minimum des distances entre chaque solution
        non dominée et le point idéal. L'attribut selected_solution est finalement mis à jour.
        """
        distances = np.array([np.sqrt(
            W1 * (solution.get_productivity() - PRODUCTIVITY_MAX) ** 2 +
            W2 * (solution.get_inhabited_area_proximity() - PROXIMITY_MAX) ** 2 +
            W3 * (solution.get_compactness() - COMPACTNESS_MAX) ** 2)
            for solution in self.non_dominated_solutions
        ])
        index_selected_solution = np.argmin(distances)
        self.selected_solution = self.non_dominated_solutions[index_selected_solution]

    def save_selected_solution_to_csv(self):
        """
        Sauvegarde la solution sélectionnée dans un fichier CSV.
        """
        np.savetxt(OUTPUT + "solution.csv", self.selected_solution.get_coordinates_list(), delimiter=",", fmt="%d")

    def run_pls_algorithm(self):
        """
        Cet algorithme exécute une recherche locale en itérant pendant ITERATIONS_NUMBER.
        L'algorithme recherche de manière itérative des meilleures solutions, met à jour l'ensemble des solutions,
        identifie les solutions non dominées et sélectionne finalement la meilleure solution.
        Les coordonnées de la meilleure solution sont finalement enregistrées dans un fichier CSV.
        """
        for _ in tqdm(range(ITERATIONS_NUMBER)):
            better_solutions = []
            for solution in self.solutions:
                better_solution = self.find_better_solution(solution)
                better_solutions.append(better_solution)
            self.set_solutions(better_solutions)
        self.set_non_dominated_solutions()
        self.find_best_solution()
        self.save_selected_solution_to_csv()

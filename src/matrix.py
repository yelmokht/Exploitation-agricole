from constants import UNOCCUPIED, ROAD, HABITATION, ROWS_NUMBER, COLUMNS_NUMBER, OUTPUT
import numpy as np


def get_matrix(file_path):
    """
    Si fichier de cout et prod, rend matrice simple
    Si fichier usage map, matrice avec maison = 3, route = 1 et vide = 2 (pour représenter facilement sur matplotlib)
    """
    with open(file_path, 'r') as file:
        data = file.read()

    rows = []
    for line in data.splitlines():
        row = [int(line[i:i + 1].replace(' ', str(UNOCCUPIED)).replace('R', str(ROAD)).replace('C', str(HABITATION)))
               for i
               in range(0, len(line), 1)]
        rows.append(row)

    matrix = np.array(rows)
    return matrix


def get_proximity_matrix(usage_map_matrix):
    """
    Rend une matrice avec pour chaque case la distance à la maison la plus proche
    """
    matrix = np.zeros_like(usage_map_matrix, dtype=float)
    for i in range(usage_map_matrix.shape[0]):
        for j in range(usage_map_matrix.shape[1]):
            if usage_map_matrix[i][j] != HABITATION:
                distance = np.sqrt(
                    np.min([(i - x) ** 2 + (j - y) ** 2 for x, y in np.argwhere(usage_map_matrix == HABITATION)]))
                matrix[i][j] = distance
    np.savetxt(OUTPUT + "Proximity_map.txt", matrix, fmt="%d")
    return matrix


def get_occupancy_matrix(usage_map_matrix):
    """
    Rend une matrice avec des 1 aux endroits vides et des 0 aux endroits occupés
    """
    matrix = np.empty((len(usage_map_matrix), len(usage_map_matrix[0])), dtype=int)
    for i in range(len(usage_map_matrix)):
        for j in range(len(usage_map_matrix[0])):
            if usage_map_matrix[i][j] != UNOCCUPIED:
                matrix[i][j] = 0
            else:
                matrix[i][j] = 1
    return matrix


def get_matrix_from_coords(liste_plots):
    """
    Prend une liste de coordonnées et
    rend une matrice avec des 1 aux coordonnées données
    """
    matrix = np.zeros((ROWS_NUMBER, COLUMNS_NUMBER), dtype=int)
    for plot in liste_plots:
        matrix[plot.get_coordinates()] = 1
    return matrix


def extract_smaller_matrix(large_matrix):
    """
    Rend la plus petite matrice contenant tous les 1s de la matrice large_matrix
    """
    if np.count_nonzero(large_matrix) == 0:
        # Return empty matrix if there are no 1s in the input matrix
        return np.array([])

    indices = np.argwhere(large_matrix == 1)

    # Determine the smallest sub-matrix containing all the 1s
    rows = np.unique(indices[:, 0])
    cols = np.unique(indices[:, 1])
    return large_matrix[rows.min():rows.max() + 2, cols.min():cols.max() + 2]

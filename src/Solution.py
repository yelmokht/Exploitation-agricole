from Plot import Plot
from matrix import extract_smaller_matrix, get_matrix_from_coords
from constants import BUDGET


class Solution:
    """
    Classe Solution représentant un terrain de parcelles.

    Attributs :
        liste_plots : Une liste qui contient les parcelles présentes sur le terrain
        productivity : La productivité totale du terrain
        inhabited_area_proximity : La proximité totale du terrain par rapport aux zones habitées
        compactness : La compacité du terrain
        cost : Le coût total du terrain
        local_optimum : Un indicateur booléen pour indiquer si la solution est un optimum local (True) ou non (False)
    """

    def __init__(self, plot: Plot):
        self.plots_list = []
        self.productivity = 0
        self.inhabited_area_proximity = 0
        self.compactness = 0
        self.cost = 0
        self.add_plot(plot)

    def get_plots_list(self):
        return self.plots_list

    def get_coordinates_list(self):
        coordinates_list = [(plot.get_x(), plot.get_y()) for plot in self.plots_list]
        return coordinates_list

    def get_productivity(self):
        return self.productivity

    def get_inhabited_area_proximity(self):
        return self.inhabited_area_proximity

    def get_compactness(self):
        return self.compactness

    def get_cost(self):
        return self.cost

    def set_productivity(self, productivity):
        self.productivity = productivity

    def set_inhabited_area_proximity(self, inhabited_area_proximity):
        self.inhabited_area_proximity = inhabited_area_proximity

    def set_compactness(self, compactness):
        self.compactness = compactness

    def set_cost(self, cost):
        self.cost = cost

    def is_under_budget(self):
        return self.cost <= BUDGET

    def is_plot_addable(self, plot: Plot):
        """
        Vérifie si une parcelle peut être ajoutée au terrain tout en respectant le budget.

        :param plot: La parcelle à vérifier.
        :return: True si la parcelle peut être ajoutée, False sinon.
        """
        return self.cost + plot.get_cost() <= BUDGET

    def is_plot_swappable(self, plot_to_remove: Plot, plot_to_add: Plot):
        """
        Vérifie si un échange de parcelles est possible tout en respectant le budget.

        :param plot_to_remove: La parcelle à supprimer.
        :param plot_to_add: La parcelle à ajouter.
        :return: True si l'échange est possible, False sinon.
        """
        return self.cost - plot_to_remove.get_cost() + plot_to_add.get_cost() <= BUDGET

    def compute_compactness(self):
        """
        Calcule la compacité du terrain.

        Cette méthode itère sur une matrice représentant la disposition des parcelles et compte le nombre de voisins
        (jusqu'à 8) autour de chaque parcelle.
        La compacité est calculée en attribuant un poids de 1/8 à chaque voisin adjacent à une parcelle.
        La valeur totale de compacité est obtenue en sommant les poids pour toutes les parcelles.

        :return: La valeur de compacité calculée.
        """
        compactness = 0
        matrix = extract_smaller_matrix(get_matrix_from_coords(self.plots_list))
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 1:
                    nEight = 0
                    for m in range(-1, 2):
                        for n in range(-1, 2):
                            if 0 <= i + m < len(matrix) and 0 <= j + n < len(matrix[0]):
                                if matrix[i + m][j + n] == 1 and (i + m != i or j + n != j):
                                    nEight += 1 / 8
                    compactness += nEight
        if compactness == 0:
            compactness = 0.01
        return compactness

    def add_plot(self, new_plot: Plot):
        """
        Ajoute une nouvelle parcelle au terrain.

        :param new_plot: La nouvelle parcelle à ajouter
        """
        self.plots_list.append(new_plot)
        self.set_productivity(self.productivity + new_plot.get_productivity())
        self.set_inhabited_area_proximity((self.inhabited_area_proximity * (len(self.plots_list) - 1) + new_plot.get_inhabited_area_proximity()) / len(self.plots_list))
        self.set_compactness(self.compute_compactness())
        self.set_cost(self.cost + new_plot.get_cost())

    def remove_plot(self, old_plot: Plot):
        """
        Supprime une parcelle existante du terrain.

        :param old_plot: La parcelle existante à supprimer
        """
        if len(self.plots_list) > 1:
            self.plots_list.remove(old_plot)
            self.set_productivity(self.productivity - old_plot.get_productivity())
            self.set_inhabited_area_proximity((self.inhabited_area_proximity * (len(self.plots_list) + 1) - old_plot.get_inhabited_area_proximity()) / len(self.plots_list))
            self.set_compactness(self.compute_compactness())
            self.set_cost(self.cost - old_plot.get_cost())

    def swap_plot(self, old_plot: Plot, new_plot: Plot):
        """
        Remplace une parcelle existante par une nouvelle parcelle.

        :param old_plot: La parcelle existante à supprimer
        :param new_plot: La nouvelle parcelle à ajouter
        """
        self.remove_plot(old_plot)
        self.add_plot(new_plot)


